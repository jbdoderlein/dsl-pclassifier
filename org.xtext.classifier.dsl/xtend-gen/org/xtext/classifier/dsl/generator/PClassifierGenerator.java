/**
 * generated by Xtext 2.26.0
 */
package org.xtext.classifier.dsl.generator;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.classifier.dsl.pClassifier.Classifier;
import org.xtext.classifier.dsl.pClassifier.Evaluation;
import org.xtext.classifier.dsl.pClassifier.EvaluationList;
import org.xtext.classifier.dsl.pClassifier.Execute;
import org.xtext.classifier.dsl.pClassifier.FeatureList;
import org.xtext.classifier.dsl.pClassifier.Load;
import org.xtext.classifier.dsl.pClassifier.MLModel;
import org.xtext.classifier.dsl.pClassifier.Save;
import org.xtext.classifier.dsl.pClassifier.Train;

@SuppressWarnings("all")
public class PClassifierGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("import numpy as np");
    _builder.newLine();
    _builder.append("import pandas as pd");
    _builder.newLine();
    _builder.append("import pickle");
    _builder.newLine();
    _builder.append("from sklearn.model_selection import train_test_split");
    _builder.newLine();
    _builder.append("from sklearn.tree import DecisionTreeClassifier");
    _builder.newLine();
    _builder.append("from sklearn.metrics import accuracy_score, confusion_matrix, f1_score, recall_score");
    _builder.newLine();
    _builder.newLine();
    _builder.append("models = {}");
    _builder.newLine();
    _builder.newLine();
    String result = _builder.toString();
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(resource.getAllContents());
    for (final EObject e : _iterable) {
      boolean _matched = false;
      if ((e instanceof Classifier)) {
        _matched=true;
        String _result = result;
        CharSequence _generateClassifier = this.generateClassifier(((Classifier) e));
        result = (_result + _generateClassifier);
        String _result_1 = result;
        result = (_result_1 + "\n");
      }
      if (!_matched) {
        if ((e instanceof Train)) {
          _matched=true;
          String _result_2 = result;
          CharSequence _generateTrain = this.generateTrain(((Train) e));
          result = (_result_2 + _generateTrain);
          String _result_3 = result;
          result = (_result_3 + "\n");
        }
      }
      if (!_matched) {
        if ((e instanceof Execute)) {
          _matched=true;
          String _result_4 = result;
          CharSequence _generateExecute = this.generateExecute(((Execute) e));
          result = (_result_4 + _generateExecute);
          String _result_5 = result;
          result = (_result_5 + "\n");
        }
      }
      if (!_matched) {
        if ((e instanceof Load)) {
          _matched=true;
          String _result_6 = result;
          CharSequence _generateLoad = this.generateLoad(((Load) e));
          result = (_result_6 + _generateLoad);
          String _result_7 = result;
          result = (_result_7 + "\n");
        }
      }
      if (!_matched) {
        if ((e instanceof Save)) {
          _matched=true;
          String _result_8 = result;
          CharSequence _generateSave = this.generateSave(((Save) e));
          result = (_result_8 + _generateSave);
          String _result_9 = result;
          result = (_result_9 + "\n");
        }
      }
    }
    fsa.generateFile("result.py", result);
  }
  
  private CharSequence generateClassifier(final Classifier classifier) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("class ");
    String _name = classifier.getName();
    _builder.append(_name);
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("features = [");
    String _handleFeatures = this.handleFeatures(classifier.getFeatures());
    _builder.append(_handleFeatures, "\t");
    _builder.append("]");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("target = \"");
    String _target = classifier.getTarget();
    _builder.append(_target, "\t");
    _builder.append("\"");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def __init__(self):");
    _builder.newLine();
    _builder.append("\t\t");
    String _handleMLModel = this.handleMLModel(classifier.getModel());
    _builder.append(_handleMLModel, "\t\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def train(self, data, split, evaluations):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("train, test = train_test_split(data, test_size=split)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("self.model.fit(train[self.features], train[self.target])");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("self.evaluate(test, evaluations)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def evaluate(self, test, evaluations):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("results_eval = {}");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("for evaluation in evaluations:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("if evaluation == \'accuracy\':");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("results_eval[evaluation] = accuracy_score(test[self.target], self.model.predict(test[self.features]))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("elif evaluation == \'confusion_matrix\':");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("results_eval[evaluation] = confusion_matrix(test[self.target], self.model.predict(test[self.features]))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("elif evaluation == \'f1_score\':");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("results_eval[evaluation] = f1_score(test[self.target], self.model.predict(test[self.features]))");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("elif evaluation == \'recall\':");
    _builder.newLine();
    _builder.append("\t\t\t\t");
    _builder.append("results_eval[evaluation] = recall_score(test[self.target], self.model.predict(test[self.features]))");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("print(");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("\'");
    String _name_1 = classifier.getName();
    _builder.append(_name_1, "\t\t\t");
    _builder.append(" training results :\\n\'+ ");
    _builder.newLineIfNotEmpty();
    _builder.append("\t\t\t");
    _builder.append("pd.DataFrame({\'Score\':list(results_eval.keys()), \'\':list(results_eval.values())}).to_markdown(index=False)");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append(")");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def execute(self, data, output):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("with open(output, \'w\') as f:");
    _builder.newLine();
    _builder.append("\t\t\t");
    _builder.append("f.write(self.model.predict(data[self.features]).to_string(index=False))");
    _builder.newLine();
    _builder.newLine();
    _builder.append("models[\"");
    String _name_2 = classifier.getName();
    _builder.append(_name_2);
    _builder.append("\"] = ");
    String _name_3 = classifier.getName();
    _builder.append(_name_3);
    _builder.append("()");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateTrain(final Train train) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("df = pd.read_csv(\"");
    String _dataset = train.getDataset();
    _builder.append(_dataset);
    _builder.append("\")");
    _builder.newLineIfNotEmpty();
    _builder.append("classifier = models[\"");
    String _name = train.getName();
    _builder.append(_name);
    _builder.append("\"].train(data=df, split=");
    double _split = train.getSplit();
    _builder.append(_split);
    _builder.append(", evaluations=[");
    String _handleEvaluationList = this.handleEvaluationList(train.getEvaluations());
    _builder.append(_handleEvaluationList);
    _builder.append("])");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateExecute(final Execute exec) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("df = pd.read_csv(\"");
    String _input = exec.getInput();
    _builder.append(_input);
    _builder.append("\")");
    _builder.newLineIfNotEmpty();
    _builder.append("models[\"");
    String _name = exec.getName();
    _builder.append(_name);
    _builder.append("\"].execute(df, \"");
    String _output = exec.getOutput();
    _builder.append(_output);
    _builder.append("\")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateLoad(final Load load) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("with open(\"");
    String _file = load.getFile();
    _builder.append(_file);
    _builder.append("\", \"r\") as f:");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("models[\"");
    String _name = load.getName();
    _builder.append(_name, "\t");
    _builder.append("\"] = pickle.load(f)");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateSave(final Save save) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("with open(\"");
    String _file = save.getFile();
    _builder.append(_file);
    _builder.append("\", \"wb\") as f:");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pickle.dump(models[\"");
    String _name = save.getName();
    _builder.append(_name, "\t");
    _builder.append("\"], f)");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public String handleFeatures(final FeatureList features) {
    String _join = IterableExtensions.join(features.getVals(), "\",\"");
    String _plus = ("\"" + _join);
    return (_plus + "\"");
  }
  
  public String handleEvaluationList(final EvaluationList eval_list) {
    String _join = IterableExtensions.join(eval_list.getVals(), "\",\"");
    String _plus = ("\"" + _join);
    return (_plus + "\"");
  }
  
  public String handleMLModel(final MLModel mlmodel) {
    String result = "self.model = ";
    String _literal = mlmodel.getLiteral();
    if (_literal != null) {
      switch (_literal) {
        case "DecisionTree":
          String _result = result;
          result = (_result + "DecisionTreeClassifier(random_state=0, max_depth=5)");
          break;
        case "SVM":
          String _result_1 = result;
          result = (_result_1 + "DecisionTree(random_state=0, max_depth=5)");
          break;
      }
    }
    return result;
  }
  
  public String handleEvaluation(final Evaluation evaluation) {
    return evaluation.getLiteral();
  }
}
