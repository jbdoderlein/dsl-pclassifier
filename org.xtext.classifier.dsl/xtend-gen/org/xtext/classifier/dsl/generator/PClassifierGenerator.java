/**
 * generated by Xtext 2.26.0
 */
package org.xtext.classifier.dsl.generator;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.eclipse.xtext.xbase.lib.IteratorExtensions;
import org.xtext.classifier.dsl.pClassifier.Classifier;
import org.xtext.classifier.dsl.pClassifier.Eval;
import org.xtext.classifier.dsl.pClassifier.Evaluation;
import org.xtext.classifier.dsl.pClassifier.EvaluationList;
import org.xtext.classifier.dsl.pClassifier.FeatureList;
import org.xtext.classifier.dsl.pClassifier.Load;
import org.xtext.classifier.dsl.pClassifier.MLModel;
import org.xtext.classifier.dsl.pClassifier.Save;
import org.xtext.classifier.dsl.pClassifier.Train;

@SuppressWarnings("all")
public class PClassifierGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    String result = "import pandas as pd\nimport pickles\nimport sklearn\n\n";
    Iterable<EObject> _iterable = IteratorExtensions.<EObject>toIterable(resource.getAllContents());
    for (final EObject e : _iterable) {
      boolean _matched = false;
      if ((e instanceof Classifier)) {
        _matched=true;
        String _result = result;
        CharSequence _generateClassifier = this.generateClassifier(((Classifier) e));
        result = (_result + _generateClassifier);
        String _result_1 = result;
        result = (_result_1 + "\n");
      }
      if (!_matched) {
        if ((e instanceof Train)) {
          _matched=true;
          String _result_2 = result;
          CharSequence _generateTrain = this.generateTrain(((Train) e));
          result = (_result_2 + _generateTrain);
          String _result_3 = result;
          result = (_result_3 + "\n");
        }
      }
      if (!_matched) {
        if ((e instanceof Eval)) {
          _matched=true;
          String _result_4 = result;
          CharSequence _generateEval = this.generateEval(((Eval) e));
          result = (_result_4 + _generateEval);
          String _result_5 = result;
          result = (_result_5 + "\n");
        }
      }
      if (!_matched) {
        if ((e instanceof Load)) {
          _matched=true;
          String _result_6 = result;
          CharSequence _generateLoad = this.generateLoad(((Load) e));
          result = (_result_6 + _generateLoad);
          String _result_7 = result;
          result = (_result_7 + "\n");
        }
      }
      if (!_matched) {
        if ((e instanceof Save)) {
          _matched=true;
          String _result_8 = result;
          CharSequence _generateSave = this.generateSave(((Save) e));
          result = (_result_8 + _generateSave);
          String _result_9 = result;
          result = (_result_9 + "\n");
        }
      }
    }
    fsa.generateFile("test.py", result);
  }
  
  private CharSequence generateClassifier(final Classifier classifier) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("class ");
    String _name = classifier.getName();
    _builder.append(_name);
    _builder.append(":");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("features = ");
    String _handleFeatures = this.handleFeatures(classifier.getFeatures());
    _builder.append(_handleFeatures, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("target = ");
    String _target = classifier.getTarget();
    _builder.append(_target, "\t");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def __init__(self):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("pass");
    _builder.newLine();
    _builder.append("\t");
    _builder.newLine();
    _builder.append("\t");
    _builder.append("def run(*args,**kwargs):");
    _builder.newLine();
    _builder.append("\t\t");
    _builder.append("print(\"");
    String _handleMLModel = this.handleMLModel(classifier.getModel());
    _builder.append(_handleMLModel, "\t\t");
    _builder.append("\")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateTrain(final Train train) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("df = pd.read_csv(\"");
    String _dataset = train.getDataset();
    _builder.append(_dataset);
    _builder.append("\")");
    _builder.newLineIfNotEmpty();
    _builder.append("classifier = ");
    String _name = train.getName();
    _builder.append(_name);
    _builder.append("(df, ");
    double _split = train.getSplit();
    _builder.append(_split);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    _builder.append("classifier.train()");
    _builder.newLine();
    return _builder;
  }
  
  private CharSequence generateEval(final Eval eval) {
    StringConcatenation _builder = new StringConcatenation();
    String _name = eval.getName();
    _builder.append(_name);
    _builder.append(".eval(");
    String _handleEvaluationList = this.handleEvaluationList(eval.getEvaluations());
    _builder.append(_handleEvaluationList);
    _builder.append(")");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateLoad(final Load load) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("with open(\"");
    String _file = load.getFile();
    _builder.append(_file);
    _builder.append("\", \"r\") as f:");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    String _name = load.getName();
    _builder.append(_name, "\t");
    _builder.append(" = pickle.load(f)");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  private CharSequence generateSave(final Save save) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("with open(\"");
    String _file = save.getFile();
    _builder.append(_file);
    _builder.append("\", \"r\") as f:");
    _builder.newLineIfNotEmpty();
    _builder.append("\t");
    _builder.append("pickle.save (");
    String _name = save.getName();
    _builder.append(_name, "\t");
    _builder.append(", f)");
    _builder.newLineIfNotEmpty();
    return _builder;
  }
  
  public String handleFeatures(final FeatureList features) {
    String _join = IterableExtensions.join(features.getVals(), "\",\"");
    String _plus = ("\"" + _join);
    return (_plus + "\"");
  }
  
  public String handleEvaluationList(final EvaluationList eval_list) {
    String _join = IterableExtensions.join(eval_list.getVals(), "\",\"");
    String _plus = ("\"" + _join);
    return (_plus + "\"");
  }
  
  public String handleMLModel(final MLModel mlmodel) {
    return mlmodel.getLiteral();
  }
  
  public String handleEvaluation(final Evaluation evaluation) {
    return evaluation.getLiteral();
  }
}
