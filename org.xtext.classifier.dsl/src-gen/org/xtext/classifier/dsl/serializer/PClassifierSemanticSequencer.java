/*
 * generated by Xtext 2.26.0
 */
package org.xtext.classifier.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.classifier.dsl.pClassifier.Classifier;
import org.xtext.classifier.dsl.pClassifier.EvaluationList;
import org.xtext.classifier.dsl.pClassifier.Execute;
import org.xtext.classifier.dsl.pClassifier.FeatureList;
import org.xtext.classifier.dsl.pClassifier.Load;
import org.xtext.classifier.dsl.pClassifier.PClassfier;
import org.xtext.classifier.dsl.pClassifier.PClassifierPackage;
import org.xtext.classifier.dsl.pClassifier.Save;
import org.xtext.classifier.dsl.pClassifier.Train;
import org.xtext.classifier.dsl.services.PClassifierGrammarAccess;

@SuppressWarnings("all")
public class PClassifierSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private PClassifierGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == PClassifierPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PClassifierPackage.CLASSIFIER:
				sequence_Classifier(context, (Classifier) semanticObject); 
				return; 
			case PClassifierPackage.EVALUATION_LIST:
				sequence_EvaluationList(context, (EvaluationList) semanticObject); 
				return; 
			case PClassifierPackage.EXECUTE:
				sequence_Execute(context, (Execute) semanticObject); 
				return; 
			case PClassifierPackage.FEATURE_LIST:
				sequence_FeatureList(context, (FeatureList) semanticObject); 
				return; 
			case PClassifierPackage.LOAD:
				sequence_Load(context, (Load) semanticObject); 
				return; 
			case PClassifierPackage.PCLASSFIER:
				sequence_PClassfier(context, (PClassfier) semanticObject); 
				return; 
			case PClassifierPackage.SAVE:
				sequence_Save(context, (Save) semanticObject); 
				return; 
			case PClassifierPackage.TRAIN:
				sequence_Train(context, (Train) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Classifier
	 *     Classifier returns Classifier
	 *
	 * Constraint:
	 *     (name=ID features=FeatureList target=STRING model=MLModel)
	 * </pre>
	 */
	protected void sequence_Classifier(ISerializationContext context, Classifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.CLASSIFIER__FEATURES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.CLASSIFIER__FEATURES));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.CLASSIFIER__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.CLASSIFIER__TARGET));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.CLASSIFIER__MODEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.CLASSIFIER__MODEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassifierAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getClassifierAccess().getFeaturesFeatureListParserRuleCall_5_0(), semanticObject.getFeatures());
		feeder.accept(grammarAccess.getClassifierAccess().getTargetSTRINGTerminalRuleCall_8_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getClassifierAccess().getModelMLModelEnumRuleCall_11_0(), semanticObject.getModel());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     EvaluationList returns EvaluationList
	 *
	 * Constraint:
	 *     (vals+=Evaluation vals+=Evaluation*)
	 * </pre>
	 */
	protected void sequence_EvaluationList(ISerializationContext context, EvaluationList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Execute
	 *     Execute returns Execute
	 *
	 * Constraint:
	 *     (name=ID input=STRING output=STRING)
	 * </pre>
	 */
	protected void sequence_Execute(ISerializationContext context, Execute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.EXECUTE__INPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.EXECUTE__INPUT));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.EXECUTE__OUTPUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.EXECUTE__OUTPUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExecuteAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getExecuteAccess().getInputSTRINGTerminalRuleCall_5_0(), semanticObject.getInput());
		feeder.accept(grammarAccess.getExecuteAccess().getOutputSTRINGTerminalRuleCall_8_0(), semanticObject.getOutput());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FeatureList returns FeatureList
	 *
	 * Constraint:
	 *     (vals+=STRING vals+=STRING*)
	 * </pre>
	 */
	protected void sequence_FeatureList(ISerializationContext context, FeatureList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Load
	 *     Load returns Load
	 *
	 * Constraint:
	 *     (name=ID file=STRING)
	 * </pre>
	 */
	protected void sequence_Load(ISerializationContext context, Load semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.LOAD__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.LOAD__FILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLoadAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLoadAccess().getFileSTRINGTerminalRuleCall_5_0(), semanticObject.getFile());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     PClassfier returns PClassfier
	 *
	 * Constraint:
	 *     elements+=Statement+
	 * </pre>
	 */
	protected void sequence_PClassfier(ISerializationContext context, PClassfier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Save
	 *     Save returns Save
	 *
	 * Constraint:
	 *     (name=ID file=STRING)
	 * </pre>
	 */
	protected void sequence_Save(ISerializationContext context, Save semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.SAVE__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.SAVE__FILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSaveAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSaveAccess().getFileSTRINGTerminalRuleCall_5_0(), semanticObject.getFile());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Train
	 *     Train returns Train
	 *
	 * Constraint:
	 *     (name=ID dataset=STRING split=FLOAT evaluations=EvaluationList)
	 * </pre>
	 */
	protected void sequence_Train(ISerializationContext context, Train semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.STATEMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.TRAIN__DATASET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.TRAIN__DATASET));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.TRAIN__SPLIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.TRAIN__SPLIT));
			if (transientValues.isValueTransient(semanticObject, PClassifierPackage.Literals.TRAIN__EVALUATIONS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, PClassifierPackage.Literals.TRAIN__EVALUATIONS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrainAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTrainAccess().getDatasetSTRINGTerminalRuleCall_5_0(), semanticObject.getDataset());
		feeder.accept(grammarAccess.getTrainAccess().getSplitFLOATTerminalRuleCall_8_0(), semanticObject.getSplit());
		feeder.accept(grammarAccess.getTrainAccess().getEvaluationsEvaluationListParserRuleCall_11_0(), semanticObject.getEvaluations());
		feeder.finish();
	}
	
	
}
